# 需求界定与技术选型

在这里界定了这个系统要达成的目标，然后根据目标划定工作范围。 

提供了技术选型，并给出了自己的理由

## 需求界定

这个系统的主要目的就是搭建一个完整的网络，因此，在很多时候并不考虑类似Bitcoin的实现。 目标是构建一个包含仅有基础功能的全节点，可以提供如下功能：

- 提供了P2P节点发现和同步区块的功能
- 提供创建公私钥对的功能
- 提供发送交易的功能
- 提供交易查询的功能
- 提供余额查询的功能
- 提供挖矿的功能，在任意地址上都可以发起单机挖矿
- 提供基础日志，方便跟踪监视

以上7个功能基本涵盖了一个区块链全节点的主要功能。

## 技术选型

区块链有四个核心概念： P2P网络，账户模型与存储，共识机制和加密模块

首先，P2P网络模块是区块链的最底层模块之一，为了便于实现和测试，可选的方案有轻量型消息队列和WebSocket。主要考虑到集成的便利性，首选WebSocket，因为至少需要提供要给HTTP JSON-RPC Server, 这里可以复用Server中的WebSocket服务。

除了通讯协议，还需要考虑数据的交换格式，我们考虑采用通用的JSON格式，而不是像比特币一样的数据序列化格式，后期更改可以考虑升级到Protobuf,后者的优势主要体现在性能上。而在不本系统中性能永远不是首要考虑的问题。

其次，账户加密部分。由于EDCSA非加密对称加密模块过于复杂，选用OpenSSL库中的RSA算法作为加密模块。而在交易模型上，这里考虑采用比特币的UTXO模型，因为状态模型需要维护状态，可能会带来额外的代码复杂度。

再次，数据存储部分。这个模块考虑到易用、易读和小巧，因此选用的常用的嵌入式SQLite 3作为持久化存储。

最后，共识模块。选用POW作为共识算法，这里考虑到POW实现起来非常简单，而且交易和区块的哈希计算会涉及SHA-256，使用POW算法时这里可以复用SHA-256的代码，最重要的是SHA-256可以降低工作量（Go有相应的实现）


## 详细功能

在叙述过技术选型后，这里对目标进行进一步分解：

- P2P网络： 发现节点，节点维护，持久化存储和区块同步
- 公私钥对： 命令行，创建公私钥对并生成地址，提供私钥存储，公钥验证
- 发送交易： 命令行，发送成功验证，输入是交易哈希
- 交易查询： 命令行，输入地址，返回JSON格式的交易查询
- 余额查询： 命令行，输入地址，返回JSON格式的余额查询
- 挖矿： 命令行，返回JSON格式的挖矿信息，输入是某个地址
- 区块共识： 编织区块链算法，包含创世区块以及调整全网挖矿难度
- 交易共识： 验证单个交易的算法，包含签名验证和UTXO验证
- 基础日志： 用于监控网络，区块验证等操作
- 区块持久化存储： 分叉与合并时的一致性，并为查询提供接口
- 提供格式化输出交易的功能，JSON格式
- 有效防止双花交易

## 区块数据结构的设计

我们采用类似Bitcoin的设计： 一个区块分为两个部分，分别是区块头和区块体，区块头是一个区块的元数据，区块体包含交易列表。

### 区块头的设计

区块头包含了 **前向区块哈希、默克尔根哈希、时间戳、难度目标、Nonce值和版本号**

因此该结构可能是这样的：

```json
{
	"target_bits" : "4575460831240",
    "hash" : 
	"4a9169e2f4f8673ac9627be0fa0f9e15a9e3b1bc5cd697d96954d25acacd92df",
	"merkle_tree_hash" : "3d228afc50bc52491f5dd8aa8c416da0d9a16bf829790ea0b7635e5b4d44ab4f",
	"nonce" : "3852714822920177480",
	"height" : 1234567,
    "previous_block_hash" : "4d2544e044bfd2f342220a711b10842bb6cfae551b1bc1ed6152ff5c7f3ff654",
    "time_stamp" : 1528070857,
    "transaction_count" : 1,
    "version" : 1
}
```
- target_bits 表示当前区块的目标值
- hash 表示当前区块的哈希值
- merkle_tree_hash 表示当前区块中交易列表的默克尔根
- nonce 表示随机数
- height 表示当前区块的高度
- previous_block_hash 指向前向区块的哈希
- time_stamp 表示产生当前区块的时间戳
- transaction_count 表示当前区块中包含多少笔交易
- version 表示区块的版本号， 不代表交易的版本号

在这里，区块头大小不是固定的，因为它没有经过序列化，完全以JSON表示，所以这里就不考虑字节印第安序问题，也不考虑固定长度的问题。

### 交易体的设计

UTXO作为交易模型，主要考虑输入和输出结构：

```json
{
    "hash": "8c14f0db3df150123e6f3dbbf30f8b955a8249b62ac1d1ff16284aefa3d06d87",
    "version": 1,
    "input_size": 1,
    "output_size": 1,
    "size": 135,
    "inputs": [{
        "prev_out": {
            "hash": "0000000000000000000000000000000000000000000000000000000000000000",
            "index":0
        },
    }],
    "out": [{
        "value": "5000000000",
        "address": "f3e6066078e815bb2"
    }],
}

```

### 地址设计

区块链地址都有通常意义上的地址，我们这里将公钥直接算作地址，不再将公钥进行哈希转换。

### 内存池设计

内存池是指缓存交易的一块交易缓冲区，这里一个节点的主要处理对象，所以对内存池的管理，是编织区块链的最重要一步。我们这里的内存池使用Go标准库中的容器。

### 哈希计算

区块和交易的哈希计算均使用SHA-256


## 代码的大致目录结构

```json
tinyChain
|-- consensus
|-- database
|-- network
|-- http-server
|-- cli-tinychain
	|-- http-client
|-- utils
	|-- log 
	|-- JSON-parser
	|-- SHA256 
	|-- key-pair
```